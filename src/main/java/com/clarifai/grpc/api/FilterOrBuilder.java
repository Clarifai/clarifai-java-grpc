// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/clarifai/api/resources.proto

package com.clarifai.grpc.api;

public interface FilterOrBuilder extends
    // @@protoc_insertion_point(interface_extends:clarifai.api.Filter)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * If True then this will flip the meaning of this part of the
   * query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
   * </pre>
   *
   * <code>bool negate = 3;</code>
   * @return The negate.
   */
  boolean getNegate();

  /**
   * <pre>
   * FILTER by annotation information.
   * ########## Supported fields ##########
   *  # Filter by ID fields
   *  - id                                      - example: `{"id": "xyz"}`
   *  - input_id
   *  - model_version_id
   *  - task_id
   *  - user_id
   *  # Filter by worker fields such as model, workflow and user IDs
   *  - worker.model.model_version.id
   *  - worker.user.id
   *  - worker.workflow.version.id
   *  # Filter by other top-level fields
   *  - annotation_info.fields                  - filter by annotation info
   *  - input_level                             - filter only input-level annotations
   *  - status.code                             - filter by annotation status code
   *  - trusted                                 - filter only trusted annotations
   *  # Filter by space-time info fields, i.e. region, frames and time-segments
   *  - data                                    - filter only annotations without space-time info, e.g. classifications
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {}}`
   *  - data.frames[].frame_info                - filter only frame annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"frames": [{"frame_info": {}}]}}`
   *  - data.regions[].region_info.bounding_box - filter only bounding box annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"bounding_box":{}}}]}}`
   *  - data.regions[].region_info.mask         - filter only mask annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"mask":{}}}]}}`
   *  - data.regions[].region_info.point        - filter only point annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"point":{}}}]}}`
   *  - data.regions[].region_info.polygon      - filter only polygon annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"polygon":{}}}]}}`
   *  - data.regions[].region_info.span         - filter only span annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"span":{}}}]}}`
   *  - data.regions[].track_id                 - filter annotations by track_id
   *                                            - in order to enable this, you need to provide "track_id_value" i.e. `{"data": {"regions": [{"track_id" : "track_id_value"}]}}`
   *  - data.time_segments[].time_info          - filter only time-segment annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"time_segments": [{"time_info": {}}]}}`
   *  # Filter by other data fields
   *  - data.clusters[].id
   *  - data.concepts[].id
   *  - data.concepts[].name
   *  - data.concepts[].value
   *  - data.geo.geo_box[].geo_point.latitude
   *  - data.geo.geo_box[].geo_point.longitude
   *  - data.geo.geo_limit.type
   *  - data.geo.geo_limit.value
   *  - data.geo.geo_point.latitude
   *  - data.geo.geo_point.longitude
   *  - data.metadata.fields                    - filter by metadata
   *                                            - Important to note: metadata key&amp;value fields are OR-ed.
   *                                            - example with 1 metadata key: searching by
   *                                                      `{
   *                                                      `  "data": {
   *                                                      `    "metadata": {
   *                                                      `      "fields": {
   *                                                      `        "foo": {
   *                                                      `          "string_value": "bar"
   *                                                      `        },
   *                                                      `      }
   *                                                      `    }
   *                                                      `  }
   *                                                      `}
   *                                                      will result in a search condition like `metadata includes {"foo": "bar}`;
   *                                            - example with 2 metadata keys: searching by
   *                                                      `{
   *                                                      `  "data": {
   *                                                      `    "metadata": {
   *                                                      `      "fields": {
   *                                                      `        "foo1": {
   *                                                      `          "string_value": "bar2"
   *                                                      `        },
   *                                                      `        "foo2": {
   *                                                      `          "string_value": "bar2"
   *                                                      `        }
   *                                                      `      }
   *                                                      `    }
   *                                                      `  }
   *                                                      `}
   *                                                      will result in a search condition like `(metadata includes {"foo1": "bar1"}) OR (metadata includes {"foo2": "bar2"})`.
   *  - data.text                               - filter only text annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"text": {}}}`
   * </pre>
   *
   * <code>.clarifai.api.Annotation annotation = 4;</code>
   * @return Whether the annotation field is set.
   */
  boolean hasAnnotation();
  /**
   * <pre>
   * FILTER by annotation information.
   * ########## Supported fields ##########
   *  # Filter by ID fields
   *  - id                                      - example: `{"id": "xyz"}`
   *  - input_id
   *  - model_version_id
   *  - task_id
   *  - user_id
   *  # Filter by worker fields such as model, workflow and user IDs
   *  - worker.model.model_version.id
   *  - worker.user.id
   *  - worker.workflow.version.id
   *  # Filter by other top-level fields
   *  - annotation_info.fields                  - filter by annotation info
   *  - input_level                             - filter only input-level annotations
   *  - status.code                             - filter by annotation status code
   *  - trusted                                 - filter only trusted annotations
   *  # Filter by space-time info fields, i.e. region, frames and time-segments
   *  - data                                    - filter only annotations without space-time info, e.g. classifications
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {}}`
   *  - data.frames[].frame_info                - filter only frame annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"frames": [{"frame_info": {}}]}}`
   *  - data.regions[].region_info.bounding_box - filter only bounding box annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"bounding_box":{}}}]}}`
   *  - data.regions[].region_info.mask         - filter only mask annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"mask":{}}}]}}`
   *  - data.regions[].region_info.point        - filter only point annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"point":{}}}]}}`
   *  - data.regions[].region_info.polygon      - filter only polygon annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"polygon":{}}}]}}`
   *  - data.regions[].region_info.span         - filter only span annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"span":{}}}]}}`
   *  - data.regions[].track_id                 - filter annotations by track_id
   *                                            - in order to enable this, you need to provide "track_id_value" i.e. `{"data": {"regions": [{"track_id" : "track_id_value"}]}}`
   *  - data.time_segments[].time_info          - filter only time-segment annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"time_segments": [{"time_info": {}}]}}`
   *  # Filter by other data fields
   *  - data.clusters[].id
   *  - data.concepts[].id
   *  - data.concepts[].name
   *  - data.concepts[].value
   *  - data.geo.geo_box[].geo_point.latitude
   *  - data.geo.geo_box[].geo_point.longitude
   *  - data.geo.geo_limit.type
   *  - data.geo.geo_limit.value
   *  - data.geo.geo_point.latitude
   *  - data.geo.geo_point.longitude
   *  - data.metadata.fields                    - filter by metadata
   *                                            - Important to note: metadata key&amp;value fields are OR-ed.
   *                                            - example with 1 metadata key: searching by
   *                                                      `{
   *                                                      `  "data": {
   *                                                      `    "metadata": {
   *                                                      `      "fields": {
   *                                                      `        "foo": {
   *                                                      `          "string_value": "bar"
   *                                                      `        },
   *                                                      `      }
   *                                                      `    }
   *                                                      `  }
   *                                                      `}
   *                                                      will result in a search condition like `metadata includes {"foo": "bar}`;
   *                                            - example with 2 metadata keys: searching by
   *                                                      `{
   *                                                      `  "data": {
   *                                                      `    "metadata": {
   *                                                      `      "fields": {
   *                                                      `        "foo1": {
   *                                                      `          "string_value": "bar2"
   *                                                      `        },
   *                                                      `        "foo2": {
   *                                                      `          "string_value": "bar2"
   *                                                      `        }
   *                                                      `      }
   *                                                      `    }
   *                                                      `  }
   *                                                      `}
   *                                                      will result in a search condition like `(metadata includes {"foo1": "bar1"}) OR (metadata includes {"foo2": "bar2"})`.
   *  - data.text                               - filter only text annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"text": {}}}`
   * </pre>
   *
   * <code>.clarifai.api.Annotation annotation = 4;</code>
   * @return The annotation.
   */
  com.clarifai.grpc.api.Annotation getAnnotation();
  /**
   * <pre>
   * FILTER by annotation information.
   * ########## Supported fields ##########
   *  # Filter by ID fields
   *  - id                                      - example: `{"id": "xyz"}`
   *  - input_id
   *  - model_version_id
   *  - task_id
   *  - user_id
   *  # Filter by worker fields such as model, workflow and user IDs
   *  - worker.model.model_version.id
   *  - worker.user.id
   *  - worker.workflow.version.id
   *  # Filter by other top-level fields
   *  - annotation_info.fields                  - filter by annotation info
   *  - input_level                             - filter only input-level annotations
   *  - status.code                             - filter by annotation status code
   *  - trusted                                 - filter only trusted annotations
   *  # Filter by space-time info fields, i.e. region, frames and time-segments
   *  - data                                    - filter only annotations without space-time info, e.g. classifications
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {}}`
   *  - data.frames[].frame_info                - filter only frame annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"frames": [{"frame_info": {}}]}}`
   *  - data.regions[].region_info.bounding_box - filter only bounding box annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"bounding_box":{}}}]}}`
   *  - data.regions[].region_info.mask         - filter only mask annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"mask":{}}}]}}`
   *  - data.regions[].region_info.point        - filter only point annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"point":{}}}]}}`
   *  - data.regions[].region_info.polygon      - filter only polygon annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"polygon":{}}}]}}`
   *  - data.regions[].region_info.span         - filter only span annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"span":{}}}]}}`
   *  - data.regions[].track_id                 - filter annotations by track_id
   *                                            - in order to enable this, you need to provide "track_id_value" i.e. `{"data": {"regions": [{"track_id" : "track_id_value"}]}}`
   *  - data.time_segments[].time_info          - filter only time-segment annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"time_segments": [{"time_info": {}}]}}`
   *  # Filter by other data fields
   *  - data.clusters[].id
   *  - data.concepts[].id
   *  - data.concepts[].name
   *  - data.concepts[].value
   *  - data.geo.geo_box[].geo_point.latitude
   *  - data.geo.geo_box[].geo_point.longitude
   *  - data.geo.geo_limit.type
   *  - data.geo.geo_limit.value
   *  - data.geo.geo_point.latitude
   *  - data.geo.geo_point.longitude
   *  - data.metadata.fields                    - filter by metadata
   *                                            - Important to note: metadata key&amp;value fields are OR-ed.
   *                                            - example with 1 metadata key: searching by
   *                                                      `{
   *                                                      `  "data": {
   *                                                      `    "metadata": {
   *                                                      `      "fields": {
   *                                                      `        "foo": {
   *                                                      `          "string_value": "bar"
   *                                                      `        },
   *                                                      `      }
   *                                                      `    }
   *                                                      `  }
   *                                                      `}
   *                                                      will result in a search condition like `metadata includes {"foo": "bar}`;
   *                                            - example with 2 metadata keys: searching by
   *                                                      `{
   *                                                      `  "data": {
   *                                                      `    "metadata": {
   *                                                      `      "fields": {
   *                                                      `        "foo1": {
   *                                                      `          "string_value": "bar2"
   *                                                      `        },
   *                                                      `        "foo2": {
   *                                                      `          "string_value": "bar2"
   *                                                      `        }
   *                                                      `      }
   *                                                      `    }
   *                                                      `  }
   *                                                      `}
   *                                                      will result in a search condition like `(metadata includes {"foo1": "bar1"}) OR (metadata includes {"foo2": "bar2"})`.
   *  - data.text                               - filter only text annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"text": {}}}`
   * </pre>
   *
   * <code>.clarifai.api.Annotation annotation = 4;</code>
   */
  com.clarifai.grpc.api.AnnotationOrBuilder getAnnotationOrBuilder();

  /**
   * <pre>
   * FILTER by input information.
   * ########## Supported fields ##########
   *  - data.audio                              - filter only audio inputs
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"audio": {}}`
   *  - data.image                              - filter only image inputs
   *                                            - enable using `{"image": {}}`
   *  - data.text                               - filter only text inputs
   *                                            - enable using `{"text": {}}`
   *  - data.video                              - filter only video inputs
   *                                            - enable using `{"video": {}}`
   *  - dataset_ids[]                           - filter by dataset IDs
   *                                            - example: `{"dataset_ids": ["d1", "d2"]}` will filter for inputs in d1 OR d2
   *  - status.code                             - filter by input status
   *                                            - example: `{"status": {"code": 30000}}` to filter only for SUCCESS inputs
   * </pre>
   *
   * <code>.clarifai.api.Input input = 5;</code>
   * @return Whether the input field is set.
   */
  boolean hasInput();
  /**
   * <pre>
   * FILTER by input information.
   * ########## Supported fields ##########
   *  - data.audio                              - filter only audio inputs
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"audio": {}}`
   *  - data.image                              - filter only image inputs
   *                                            - enable using `{"image": {}}`
   *  - data.text                               - filter only text inputs
   *                                            - enable using `{"text": {}}`
   *  - data.video                              - filter only video inputs
   *                                            - enable using `{"video": {}}`
   *  - dataset_ids[]                           - filter by dataset IDs
   *                                            - example: `{"dataset_ids": ["d1", "d2"]}` will filter for inputs in d1 OR d2
   *  - status.code                             - filter by input status
   *                                            - example: `{"status": {"code": 30000}}` to filter only for SUCCESS inputs
   * </pre>
   *
   * <code>.clarifai.api.Input input = 5;</code>
   * @return The input.
   */
  com.clarifai.grpc.api.Input getInput();
  /**
   * <pre>
   * FILTER by input information.
   * ########## Supported fields ##########
   *  - data.audio                              - filter only audio inputs
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"audio": {}}`
   *  - data.image                              - filter only image inputs
   *                                            - enable using `{"image": {}}`
   *  - data.text                               - filter only text inputs
   *                                            - enable using `{"text": {}}`
   *  - data.video                              - filter only video inputs
   *                                            - enable using `{"video": {}}`
   *  - dataset_ids[]                           - filter by dataset IDs
   *                                            - example: `{"dataset_ids": ["d1", "d2"]}` will filter for inputs in d1 OR d2
   *  - status.code                             - filter by input status
   *                                            - example: `{"status": {"code": 30000}}` to filter only for SUCCESS inputs
   * </pre>
   *
   * <code>.clarifai.api.Input input = 5;</code>
   */
  com.clarifai.grpc.api.InputOrBuilder getInputOrBuilder();

  /**
   * <pre>
   * Filter by annotation last updated time range.
   * </pre>
   *
   * <code>.clarifai.api.TimeRange last_updated_time_range = 6;</code>
   * @return Whether the lastUpdatedTimeRange field is set.
   */
  boolean hasLastUpdatedTimeRange();
  /**
   * <pre>
   * Filter by annotation last updated time range.
   * </pre>
   *
   * <code>.clarifai.api.TimeRange last_updated_time_range = 6;</code>
   * @return The lastUpdatedTimeRange.
   */
  com.clarifai.grpc.api.TimeRange getLastUpdatedTimeRange();
  /**
   * <pre>
   * Filter by annotation last updated time range.
   * </pre>
   *
   * <code>.clarifai.api.TimeRange last_updated_time_range = 6;</code>
   */
  com.clarifai.grpc.api.TimeRangeOrBuilder getLastUpdatedTimeRangeOrBuilder();
}
