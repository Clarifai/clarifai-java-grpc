// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/clarifai/api/resources.proto

package com.clarifai.grpc.api;

/**
 * Protobuf type {@code clarifai.api.TaskReviewMetrics}
 */
public final class TaskReviewMetrics extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:clarifai.api.TaskReviewMetrics)
    TaskReviewMetricsOrBuilder {
private static final long serialVersionUID = 0L;
  // Use TaskReviewMetrics.newBuilder() to construct.
  private TaskReviewMetrics(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private TaskReviewMetrics() {
    inputsCountEstimatedPerReviewer_ = emptyLongList();
    inputsReviewableCountEstimatedPerReviewer_ = emptyLongList();
    inputsPercentEstimatedPerReviewer_ = emptyIntList();
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new TaskReviewMetrics();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private TaskReviewMetrics(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 8: {

            inputsCountEstimated_ = input.readUInt64();
            break;
          }
          case 16: {

            inputsPercentEstimated_ = input.readUInt32();
            break;
          }
          case 24: {
            if (!((mutable_bitField0_ & 0x00000001) != 0)) {
              inputsCountEstimatedPerReviewer_ = newLongList();
              mutable_bitField0_ |= 0x00000001;
            }
            inputsCountEstimatedPerReviewer_.addLong(input.readUInt64());
            break;
          }
          case 26: {
            int length = input.readRawVarint32();
            int limit = input.pushLimit(length);
            if (!((mutable_bitField0_ & 0x00000001) != 0) && input.getBytesUntilLimit() > 0) {
              inputsCountEstimatedPerReviewer_ = newLongList();
              mutable_bitField0_ |= 0x00000001;
            }
            while (input.getBytesUntilLimit() > 0) {
              inputsCountEstimatedPerReviewer_.addLong(input.readUInt64());
            }
            input.popLimit(limit);
            break;
          }
          case 32: {
            if (!((mutable_bitField0_ & 0x00000002) != 0)) {
              inputsReviewableCountEstimatedPerReviewer_ = newLongList();
              mutable_bitField0_ |= 0x00000002;
            }
            inputsReviewableCountEstimatedPerReviewer_.addLong(input.readUInt64());
            break;
          }
          case 34: {
            int length = input.readRawVarint32();
            int limit = input.pushLimit(length);
            if (!((mutable_bitField0_ & 0x00000002) != 0) && input.getBytesUntilLimit() > 0) {
              inputsReviewableCountEstimatedPerReviewer_ = newLongList();
              mutable_bitField0_ |= 0x00000002;
            }
            while (input.getBytesUntilLimit() > 0) {
              inputsReviewableCountEstimatedPerReviewer_.addLong(input.readUInt64());
            }
            input.popLimit(limit);
            break;
          }
          case 40: {
            if (!((mutable_bitField0_ & 0x00000004) != 0)) {
              inputsPercentEstimatedPerReviewer_ = newIntList();
              mutable_bitField0_ |= 0x00000004;
            }
            inputsPercentEstimatedPerReviewer_.addInt(input.readUInt32());
            break;
          }
          case 42: {
            int length = input.readRawVarint32();
            int limit = input.pushLimit(length);
            if (!((mutable_bitField0_ & 0x00000004) != 0) && input.getBytesUntilLimit() > 0) {
              inputsPercentEstimatedPerReviewer_ = newIntList();
              mutable_bitField0_ |= 0x00000004;
            }
            while (input.getBytesUntilLimit() > 0) {
              inputsPercentEstimatedPerReviewer_.addInt(input.readUInt32());
            }
            input.popLimit(limit);
            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (com.google.protobuf.UninitializedMessageException e) {
      throw e.asInvalidProtocolBufferException().setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00000001) != 0)) {
        inputsCountEstimatedPerReviewer_.makeImmutable(); // C
      }
      if (((mutable_bitField0_ & 0x00000002) != 0)) {
        inputsReviewableCountEstimatedPerReviewer_.makeImmutable(); // C
      }
      if (((mutable_bitField0_ & 0x00000004) != 0)) {
        inputsPercentEstimatedPerReviewer_.makeImmutable(); // C
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return com.clarifai.grpc.api.Resources.internal_static_clarifai_api_TaskReviewMetrics_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.clarifai.grpc.api.Resources.internal_static_clarifai_api_TaskReviewMetrics_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.clarifai.grpc.api.TaskReviewMetrics.class, com.clarifai.grpc.api.TaskReviewMetrics.Builder.class);
  }

  public static final int INPUTS_COUNT_ESTIMATED_FIELD_NUMBER = 1;
  private long inputsCountEstimated_;
  /**
   * <pre>
   * Estimated number of fully reviewed inputs.
   * An input is considered fully reviewed if it has been reviewed by all necessary reviewers.
   * Example: if task has no review, then an input is considered fully reviewed right after it's labeled (as review is skipped).
   * Example: if task has manual review with single-reviewer per input, then an input is considered fully reviewed when 1 reviewer has approved/rejected it.
   * Example: if task has consensus review with 3 reviewers per input, then an input is considered fully reviewed when 3 reviewers have approved it or 1 reviewer has rejected it.
   * </pre>
   *
   * <code>uint64 inputs_count_estimated = 1;</code>
   * @return The inputsCountEstimated.
   */
  @java.lang.Override
  public long getInputsCountEstimated() {
    return inputsCountEstimated_;
  }

  public static final int INPUTS_PERCENT_ESTIMATED_FIELD_NUMBER = 2;
  private int inputsPercentEstimated_;
  /**
   * <pre>
   * Estimated percent of review work that was finished.
   * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
   * Calculated as inputs_count_estimated/task.metrics.input_source.inputs_count_estimated.
   * As the counts are estimated, the percentage is also estimated.
   * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
   * </pre>
   *
   * <code>uint32 inputs_percent_estimated = 2;</code>
   * @return The inputsPercentEstimated.
   */
  @java.lang.Override
  public int getInputsPercentEstimated() {
    return inputsPercentEstimated_;
  }

  public static final int INPUTS_COUNT_ESTIMATED_PER_REVIEWER_FIELD_NUMBER = 3;
  private com.google.protobuf.Internal.LongList inputsCountEstimatedPerReviewer_;
  /**
   * <pre>
   * Estimated number of reviewed inputs per reviewer index.
   * The reviewer indexes are based on task.review.users.
   * An input is considered reviewed by a reviewer if:
   * * the reviewer approved the input
   * * the reviewer rejected the input
   * Note that when a reviewer requests changes for an input, the input is sent to back to work again, so the whole work &amp; review process is restarted.
   * The reviewer will have to review the input again after work has been completed.
   * As such, the review that requests changes for an input is immediately dis-regarded and not counted in this metric.
   * </pre>
   *
   * <code>repeated uint64 inputs_count_estimated_per_reviewer = 3;</code>
   * @return A list containing the inputsCountEstimatedPerReviewer.
   */
  @java.lang.Override
  public java.util.List<java.lang.Long>
      getInputsCountEstimatedPerReviewerList() {
    return inputsCountEstimatedPerReviewer_;
  }
  /**
   * <pre>
   * Estimated number of reviewed inputs per reviewer index.
   * The reviewer indexes are based on task.review.users.
   * An input is considered reviewed by a reviewer if:
   * * the reviewer approved the input
   * * the reviewer rejected the input
   * Note that when a reviewer requests changes for an input, the input is sent to back to work again, so the whole work &amp; review process is restarted.
   * The reviewer will have to review the input again after work has been completed.
   * As such, the review that requests changes for an input is immediately dis-regarded and not counted in this metric.
   * </pre>
   *
   * <code>repeated uint64 inputs_count_estimated_per_reviewer = 3;</code>
   * @return The count of inputsCountEstimatedPerReviewer.
   */
  public int getInputsCountEstimatedPerReviewerCount() {
    return inputsCountEstimatedPerReviewer_.size();
  }
  /**
   * <pre>
   * Estimated number of reviewed inputs per reviewer index.
   * The reviewer indexes are based on task.review.users.
   * An input is considered reviewed by a reviewer if:
   * * the reviewer approved the input
   * * the reviewer rejected the input
   * Note that when a reviewer requests changes for an input, the input is sent to back to work again, so the whole work &amp; review process is restarted.
   * The reviewer will have to review the input again after work has been completed.
   * As such, the review that requests changes for an input is immediately dis-regarded and not counted in this metric.
   * </pre>
   *
   * <code>repeated uint64 inputs_count_estimated_per_reviewer = 3;</code>
   * @param index The index of the element to return.
   * @return The inputsCountEstimatedPerReviewer at the given index.
   */
  public long getInputsCountEstimatedPerReviewer(int index) {
    return inputsCountEstimatedPerReviewer_.getLong(index);
  }
  private int inputsCountEstimatedPerReviewerMemoizedSerializedSize = -1;

  public static final int INPUTS_REVIEWABLE_COUNT_ESTIMATED_PER_REVIEWER_FIELD_NUMBER = 4;
  private com.google.protobuf.Internal.LongList inputsReviewableCountEstimatedPerReviewer_;
  /**
   * <pre>
   * The number of inputs actually available for review for each reviewer.
   * Most times, this equals task.metrics.input_source.inputs_count_estimated.
   * Several situations may result in different values:
   * * When task has no review, then this is 0 for each reviewer.
   * * When task has auto-annotation, then this number equals the inputs that have been auto-annotated with AWAITING_REVIEW status. All other inputs are considered completed by the auto-annotation process.
   * * When task has consensus review with approval_threshold_labelers &gt; 0, then it's possible that labelers will approve inputs through consensus, which skips review. In this case, the number of inputs available for review is less than task.metrics.input_source.inputs_count_estimated.
   * * When task has consensus review with approval_threshold_reviewers = 1, then all inputs are assigned only to one reviewer, so each reviewer will get only a part of the inputs to review. It's expected that the sum(inputs_reviewable_count_estimated) = task.metrics.input_source.inputs_count_estimated.
   * * When task has consensus review with approval_threshold_reviewers = -1, then all inputs are assigned to all reviewers. However, if an input is rejected, then rejection is final and all other reviewers will not review it. In this case, the number of inputs available for review for other reviewers will be less than task.metrics.input_source.inputs_count_estimated.
   * </pre>
   *
   * <code>repeated uint64 inputs_reviewable_count_estimated_per_reviewer = 4;</code>
   * @return A list containing the inputsReviewableCountEstimatedPerReviewer.
   */
  @java.lang.Override
  public java.util.List<java.lang.Long>
      getInputsReviewableCountEstimatedPerReviewerList() {
    return inputsReviewableCountEstimatedPerReviewer_;
  }
  /**
   * <pre>
   * The number of inputs actually available for review for each reviewer.
   * Most times, this equals task.metrics.input_source.inputs_count_estimated.
   * Several situations may result in different values:
   * * When task has no review, then this is 0 for each reviewer.
   * * When task has auto-annotation, then this number equals the inputs that have been auto-annotated with AWAITING_REVIEW status. All other inputs are considered completed by the auto-annotation process.
   * * When task has consensus review with approval_threshold_labelers &gt; 0, then it's possible that labelers will approve inputs through consensus, which skips review. In this case, the number of inputs available for review is less than task.metrics.input_source.inputs_count_estimated.
   * * When task has consensus review with approval_threshold_reviewers = 1, then all inputs are assigned only to one reviewer, so each reviewer will get only a part of the inputs to review. It's expected that the sum(inputs_reviewable_count_estimated) = task.metrics.input_source.inputs_count_estimated.
   * * When task has consensus review with approval_threshold_reviewers = -1, then all inputs are assigned to all reviewers. However, if an input is rejected, then rejection is final and all other reviewers will not review it. In this case, the number of inputs available for review for other reviewers will be less than task.metrics.input_source.inputs_count_estimated.
   * </pre>
   *
   * <code>repeated uint64 inputs_reviewable_count_estimated_per_reviewer = 4;</code>
   * @return The count of inputsReviewableCountEstimatedPerReviewer.
   */
  public int getInputsReviewableCountEstimatedPerReviewerCount() {
    return inputsReviewableCountEstimatedPerReviewer_.size();
  }
  /**
   * <pre>
   * The number of inputs actually available for review for each reviewer.
   * Most times, this equals task.metrics.input_source.inputs_count_estimated.
   * Several situations may result in different values:
   * * When task has no review, then this is 0 for each reviewer.
   * * When task has auto-annotation, then this number equals the inputs that have been auto-annotated with AWAITING_REVIEW status. All other inputs are considered completed by the auto-annotation process.
   * * When task has consensus review with approval_threshold_labelers &gt; 0, then it's possible that labelers will approve inputs through consensus, which skips review. In this case, the number of inputs available for review is less than task.metrics.input_source.inputs_count_estimated.
   * * When task has consensus review with approval_threshold_reviewers = 1, then all inputs are assigned only to one reviewer, so each reviewer will get only a part of the inputs to review. It's expected that the sum(inputs_reviewable_count_estimated) = task.metrics.input_source.inputs_count_estimated.
   * * When task has consensus review with approval_threshold_reviewers = -1, then all inputs are assigned to all reviewers. However, if an input is rejected, then rejection is final and all other reviewers will not review it. In this case, the number of inputs available for review for other reviewers will be less than task.metrics.input_source.inputs_count_estimated.
   * </pre>
   *
   * <code>repeated uint64 inputs_reviewable_count_estimated_per_reviewer = 4;</code>
   * @param index The index of the element to return.
   * @return The inputsReviewableCountEstimatedPerReviewer at the given index.
   */
  public long getInputsReviewableCountEstimatedPerReviewer(int index) {
    return inputsReviewableCountEstimatedPerReviewer_.getLong(index);
  }
  private int inputsReviewableCountEstimatedPerReviewerMemoizedSerializedSize = -1;

  public static final int INPUTS_PERCENT_ESTIMATED_PER_REVIEWER_FIELD_NUMBER = 5;
  private com.google.protobuf.Internal.IntList inputsPercentEstimatedPerReviewer_;
  /**
   * <pre>
   * Estimated percent of review work that was finished per reviewer.
   * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
   * Calculated as inputs_count_estimated_per_reviewer/inputs_reviewable_count_estimated_per_reviewer.
   * As the counts are estimated, the percentage is also estimated.
   * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
   * </pre>
   *
   * <code>repeated uint32 inputs_percent_estimated_per_reviewer = 5;</code>
   * @return A list containing the inputsPercentEstimatedPerReviewer.
   */
  @java.lang.Override
  public java.util.List<java.lang.Integer>
      getInputsPercentEstimatedPerReviewerList() {
    return inputsPercentEstimatedPerReviewer_;
  }
  /**
   * <pre>
   * Estimated percent of review work that was finished per reviewer.
   * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
   * Calculated as inputs_count_estimated_per_reviewer/inputs_reviewable_count_estimated_per_reviewer.
   * As the counts are estimated, the percentage is also estimated.
   * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
   * </pre>
   *
   * <code>repeated uint32 inputs_percent_estimated_per_reviewer = 5;</code>
   * @return The count of inputsPercentEstimatedPerReviewer.
   */
  public int getInputsPercentEstimatedPerReviewerCount() {
    return inputsPercentEstimatedPerReviewer_.size();
  }
  /**
   * <pre>
   * Estimated percent of review work that was finished per reviewer.
   * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
   * Calculated as inputs_count_estimated_per_reviewer/inputs_reviewable_count_estimated_per_reviewer.
   * As the counts are estimated, the percentage is also estimated.
   * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
   * </pre>
   *
   * <code>repeated uint32 inputs_percent_estimated_per_reviewer = 5;</code>
   * @param index The index of the element to return.
   * @return The inputsPercentEstimatedPerReviewer at the given index.
   */
  public int getInputsPercentEstimatedPerReviewer(int index) {
    return inputsPercentEstimatedPerReviewer_.getInt(index);
  }
  private int inputsPercentEstimatedPerReviewerMemoizedSerializedSize = -1;

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    getSerializedSize();
    if (inputsCountEstimated_ != 0L) {
      output.writeUInt64(1, inputsCountEstimated_);
    }
    if (inputsPercentEstimated_ != 0) {
      output.writeUInt32(2, inputsPercentEstimated_);
    }
    if (getInputsCountEstimatedPerReviewerList().size() > 0) {
      output.writeUInt32NoTag(26);
      output.writeUInt32NoTag(inputsCountEstimatedPerReviewerMemoizedSerializedSize);
    }
    for (int i = 0; i < inputsCountEstimatedPerReviewer_.size(); i++) {
      output.writeUInt64NoTag(inputsCountEstimatedPerReviewer_.getLong(i));
    }
    if (getInputsReviewableCountEstimatedPerReviewerList().size() > 0) {
      output.writeUInt32NoTag(34);
      output.writeUInt32NoTag(inputsReviewableCountEstimatedPerReviewerMemoizedSerializedSize);
    }
    for (int i = 0; i < inputsReviewableCountEstimatedPerReviewer_.size(); i++) {
      output.writeUInt64NoTag(inputsReviewableCountEstimatedPerReviewer_.getLong(i));
    }
    if (getInputsPercentEstimatedPerReviewerList().size() > 0) {
      output.writeUInt32NoTag(42);
      output.writeUInt32NoTag(inputsPercentEstimatedPerReviewerMemoizedSerializedSize);
    }
    for (int i = 0; i < inputsPercentEstimatedPerReviewer_.size(); i++) {
      output.writeUInt32NoTag(inputsPercentEstimatedPerReviewer_.getInt(i));
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (inputsCountEstimated_ != 0L) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt64Size(1, inputsCountEstimated_);
    }
    if (inputsPercentEstimated_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt32Size(2, inputsPercentEstimated_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < inputsCountEstimatedPerReviewer_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeUInt64SizeNoTag(inputsCountEstimatedPerReviewer_.getLong(i));
      }
      size += dataSize;
      if (!getInputsCountEstimatedPerReviewerList().isEmpty()) {
        size += 1;
        size += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(dataSize);
      }
      inputsCountEstimatedPerReviewerMemoizedSerializedSize = dataSize;
    }
    {
      int dataSize = 0;
      for (int i = 0; i < inputsReviewableCountEstimatedPerReviewer_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeUInt64SizeNoTag(inputsReviewableCountEstimatedPerReviewer_.getLong(i));
      }
      size += dataSize;
      if (!getInputsReviewableCountEstimatedPerReviewerList().isEmpty()) {
        size += 1;
        size += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(dataSize);
      }
      inputsReviewableCountEstimatedPerReviewerMemoizedSerializedSize = dataSize;
    }
    {
      int dataSize = 0;
      for (int i = 0; i < inputsPercentEstimatedPerReviewer_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeUInt32SizeNoTag(inputsPercentEstimatedPerReviewer_.getInt(i));
      }
      size += dataSize;
      if (!getInputsPercentEstimatedPerReviewerList().isEmpty()) {
        size += 1;
        size += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(dataSize);
      }
      inputsPercentEstimatedPerReviewerMemoizedSerializedSize = dataSize;
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof com.clarifai.grpc.api.TaskReviewMetrics)) {
      return super.equals(obj);
    }
    com.clarifai.grpc.api.TaskReviewMetrics other = (com.clarifai.grpc.api.TaskReviewMetrics) obj;

    if (getInputsCountEstimated()
        != other.getInputsCountEstimated()) return false;
    if (getInputsPercentEstimated()
        != other.getInputsPercentEstimated()) return false;
    if (!getInputsCountEstimatedPerReviewerList()
        .equals(other.getInputsCountEstimatedPerReviewerList())) return false;
    if (!getInputsReviewableCountEstimatedPerReviewerList()
        .equals(other.getInputsReviewableCountEstimatedPerReviewerList())) return false;
    if (!getInputsPercentEstimatedPerReviewerList()
        .equals(other.getInputsPercentEstimatedPerReviewerList())) return false;
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + INPUTS_COUNT_ESTIMATED_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        getInputsCountEstimated());
    hash = (37 * hash) + INPUTS_PERCENT_ESTIMATED_FIELD_NUMBER;
    hash = (53 * hash) + getInputsPercentEstimated();
    if (getInputsCountEstimatedPerReviewerCount() > 0) {
      hash = (37 * hash) + INPUTS_COUNT_ESTIMATED_PER_REVIEWER_FIELD_NUMBER;
      hash = (53 * hash) + getInputsCountEstimatedPerReviewerList().hashCode();
    }
    if (getInputsReviewableCountEstimatedPerReviewerCount() > 0) {
      hash = (37 * hash) + INPUTS_REVIEWABLE_COUNT_ESTIMATED_PER_REVIEWER_FIELD_NUMBER;
      hash = (53 * hash) + getInputsReviewableCountEstimatedPerReviewerList().hashCode();
    }
    if (getInputsPercentEstimatedPerReviewerCount() > 0) {
      hash = (37 * hash) + INPUTS_PERCENT_ESTIMATED_PER_REVIEWER_FIELD_NUMBER;
      hash = (53 * hash) + getInputsPercentEstimatedPerReviewerList().hashCode();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.clarifai.grpc.api.TaskReviewMetrics parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.clarifai.grpc.api.TaskReviewMetrics parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.clarifai.grpc.api.TaskReviewMetrics parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.clarifai.grpc.api.TaskReviewMetrics parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.clarifai.grpc.api.TaskReviewMetrics parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.clarifai.grpc.api.TaskReviewMetrics parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.clarifai.grpc.api.TaskReviewMetrics parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static com.clarifai.grpc.api.TaskReviewMetrics parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static com.clarifai.grpc.api.TaskReviewMetrics parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static com.clarifai.grpc.api.TaskReviewMetrics parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static com.clarifai.grpc.api.TaskReviewMetrics parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static com.clarifai.grpc.api.TaskReviewMetrics parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.clarifai.grpc.api.TaskReviewMetrics prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * Protobuf type {@code clarifai.api.TaskReviewMetrics}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:clarifai.api.TaskReviewMetrics)
      com.clarifai.grpc.api.TaskReviewMetricsOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.clarifai.grpc.api.Resources.internal_static_clarifai_api_TaskReviewMetrics_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.clarifai.grpc.api.Resources.internal_static_clarifai_api_TaskReviewMetrics_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.clarifai.grpc.api.TaskReviewMetrics.class, com.clarifai.grpc.api.TaskReviewMetrics.Builder.class);
    }

    // Construct using com.clarifai.grpc.api.TaskReviewMetrics.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      inputsCountEstimated_ = 0L;

      inputsPercentEstimated_ = 0;

      inputsCountEstimatedPerReviewer_ = emptyLongList();
      bitField0_ = (bitField0_ & ~0x00000001);
      inputsReviewableCountEstimatedPerReviewer_ = emptyLongList();
      bitField0_ = (bitField0_ & ~0x00000002);
      inputsPercentEstimatedPerReviewer_ = emptyIntList();
      bitField0_ = (bitField0_ & ~0x00000004);
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return com.clarifai.grpc.api.Resources.internal_static_clarifai_api_TaskReviewMetrics_descriptor;
    }

    @java.lang.Override
    public com.clarifai.grpc.api.TaskReviewMetrics getDefaultInstanceForType() {
      return com.clarifai.grpc.api.TaskReviewMetrics.getDefaultInstance();
    }

    @java.lang.Override
    public com.clarifai.grpc.api.TaskReviewMetrics build() {
      com.clarifai.grpc.api.TaskReviewMetrics result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.clarifai.grpc.api.TaskReviewMetrics buildPartial() {
      com.clarifai.grpc.api.TaskReviewMetrics result = new com.clarifai.grpc.api.TaskReviewMetrics(this);
      int from_bitField0_ = bitField0_;
      result.inputsCountEstimated_ = inputsCountEstimated_;
      result.inputsPercentEstimated_ = inputsPercentEstimated_;
      if (((bitField0_ & 0x00000001) != 0)) {
        inputsCountEstimatedPerReviewer_.makeImmutable();
        bitField0_ = (bitField0_ & ~0x00000001);
      }
      result.inputsCountEstimatedPerReviewer_ = inputsCountEstimatedPerReviewer_;
      if (((bitField0_ & 0x00000002) != 0)) {
        inputsReviewableCountEstimatedPerReviewer_.makeImmutable();
        bitField0_ = (bitField0_ & ~0x00000002);
      }
      result.inputsReviewableCountEstimatedPerReviewer_ = inputsReviewableCountEstimatedPerReviewer_;
      if (((bitField0_ & 0x00000004) != 0)) {
        inputsPercentEstimatedPerReviewer_.makeImmutable();
        bitField0_ = (bitField0_ & ~0x00000004);
      }
      result.inputsPercentEstimatedPerReviewer_ = inputsPercentEstimatedPerReviewer_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.clarifai.grpc.api.TaskReviewMetrics) {
        return mergeFrom((com.clarifai.grpc.api.TaskReviewMetrics)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.clarifai.grpc.api.TaskReviewMetrics other) {
      if (other == com.clarifai.grpc.api.TaskReviewMetrics.getDefaultInstance()) return this;
      if (other.getInputsCountEstimated() != 0L) {
        setInputsCountEstimated(other.getInputsCountEstimated());
      }
      if (other.getInputsPercentEstimated() != 0) {
        setInputsPercentEstimated(other.getInputsPercentEstimated());
      }
      if (!other.inputsCountEstimatedPerReviewer_.isEmpty()) {
        if (inputsCountEstimatedPerReviewer_.isEmpty()) {
          inputsCountEstimatedPerReviewer_ = other.inputsCountEstimatedPerReviewer_;
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          ensureInputsCountEstimatedPerReviewerIsMutable();
          inputsCountEstimatedPerReviewer_.addAll(other.inputsCountEstimatedPerReviewer_);
        }
        onChanged();
      }
      if (!other.inputsReviewableCountEstimatedPerReviewer_.isEmpty()) {
        if (inputsReviewableCountEstimatedPerReviewer_.isEmpty()) {
          inputsReviewableCountEstimatedPerReviewer_ = other.inputsReviewableCountEstimatedPerReviewer_;
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          ensureInputsReviewableCountEstimatedPerReviewerIsMutable();
          inputsReviewableCountEstimatedPerReviewer_.addAll(other.inputsReviewableCountEstimatedPerReviewer_);
        }
        onChanged();
      }
      if (!other.inputsPercentEstimatedPerReviewer_.isEmpty()) {
        if (inputsPercentEstimatedPerReviewer_.isEmpty()) {
          inputsPercentEstimatedPerReviewer_ = other.inputsPercentEstimatedPerReviewer_;
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          ensureInputsPercentEstimatedPerReviewerIsMutable();
          inputsPercentEstimatedPerReviewer_.addAll(other.inputsPercentEstimatedPerReviewer_);
        }
        onChanged();
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      com.clarifai.grpc.api.TaskReviewMetrics parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.clarifai.grpc.api.TaskReviewMetrics) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int bitField0_;

    private long inputsCountEstimated_ ;
    /**
     * <pre>
     * Estimated number of fully reviewed inputs.
     * An input is considered fully reviewed if it has been reviewed by all necessary reviewers.
     * Example: if task has no review, then an input is considered fully reviewed right after it's labeled (as review is skipped).
     * Example: if task has manual review with single-reviewer per input, then an input is considered fully reviewed when 1 reviewer has approved/rejected it.
     * Example: if task has consensus review with 3 reviewers per input, then an input is considered fully reviewed when 3 reviewers have approved it or 1 reviewer has rejected it.
     * </pre>
     *
     * <code>uint64 inputs_count_estimated = 1;</code>
     * @return The inputsCountEstimated.
     */
    @java.lang.Override
    public long getInputsCountEstimated() {
      return inputsCountEstimated_;
    }
    /**
     * <pre>
     * Estimated number of fully reviewed inputs.
     * An input is considered fully reviewed if it has been reviewed by all necessary reviewers.
     * Example: if task has no review, then an input is considered fully reviewed right after it's labeled (as review is skipped).
     * Example: if task has manual review with single-reviewer per input, then an input is considered fully reviewed when 1 reviewer has approved/rejected it.
     * Example: if task has consensus review with 3 reviewers per input, then an input is considered fully reviewed when 3 reviewers have approved it or 1 reviewer has rejected it.
     * </pre>
     *
     * <code>uint64 inputs_count_estimated = 1;</code>
     * @param value The inputsCountEstimated to set.
     * @return This builder for chaining.
     */
    public Builder setInputsCountEstimated(long value) {
      
      inputsCountEstimated_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Estimated number of fully reviewed inputs.
     * An input is considered fully reviewed if it has been reviewed by all necessary reviewers.
     * Example: if task has no review, then an input is considered fully reviewed right after it's labeled (as review is skipped).
     * Example: if task has manual review with single-reviewer per input, then an input is considered fully reviewed when 1 reviewer has approved/rejected it.
     * Example: if task has consensus review with 3 reviewers per input, then an input is considered fully reviewed when 3 reviewers have approved it or 1 reviewer has rejected it.
     * </pre>
     *
     * <code>uint64 inputs_count_estimated = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearInputsCountEstimated() {
      
      inputsCountEstimated_ = 0L;
      onChanged();
      return this;
    }

    private int inputsPercentEstimated_ ;
    /**
     * <pre>
     * Estimated percent of review work that was finished.
     * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
     * Calculated as inputs_count_estimated/task.metrics.input_source.inputs_count_estimated.
     * As the counts are estimated, the percentage is also estimated.
     * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
     * </pre>
     *
     * <code>uint32 inputs_percent_estimated = 2;</code>
     * @return The inputsPercentEstimated.
     */
    @java.lang.Override
    public int getInputsPercentEstimated() {
      return inputsPercentEstimated_;
    }
    /**
     * <pre>
     * Estimated percent of review work that was finished.
     * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
     * Calculated as inputs_count_estimated/task.metrics.input_source.inputs_count_estimated.
     * As the counts are estimated, the percentage is also estimated.
     * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
     * </pre>
     *
     * <code>uint32 inputs_percent_estimated = 2;</code>
     * @param value The inputsPercentEstimated to set.
     * @return This builder for chaining.
     */
    public Builder setInputsPercentEstimated(int value) {
      
      inputsPercentEstimated_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Estimated percent of review work that was finished.
     * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
     * Calculated as inputs_count_estimated/task.metrics.input_source.inputs_count_estimated.
     * As the counts are estimated, the percentage is also estimated.
     * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
     * </pre>
     *
     * <code>uint32 inputs_percent_estimated = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearInputsPercentEstimated() {
      
      inputsPercentEstimated_ = 0;
      onChanged();
      return this;
    }

    private com.google.protobuf.Internal.LongList inputsCountEstimatedPerReviewer_ = emptyLongList();
    private void ensureInputsCountEstimatedPerReviewerIsMutable() {
      if (!((bitField0_ & 0x00000001) != 0)) {
        inputsCountEstimatedPerReviewer_ = mutableCopy(inputsCountEstimatedPerReviewer_);
        bitField0_ |= 0x00000001;
       }
    }
    /**
     * <pre>
     * Estimated number of reviewed inputs per reviewer index.
     * The reviewer indexes are based on task.review.users.
     * An input is considered reviewed by a reviewer if:
     * * the reviewer approved the input
     * * the reviewer rejected the input
     * Note that when a reviewer requests changes for an input, the input is sent to back to work again, so the whole work &amp; review process is restarted.
     * The reviewer will have to review the input again after work has been completed.
     * As such, the review that requests changes for an input is immediately dis-regarded and not counted in this metric.
     * </pre>
     *
     * <code>repeated uint64 inputs_count_estimated_per_reviewer = 3;</code>
     * @return A list containing the inputsCountEstimatedPerReviewer.
     */
    public java.util.List<java.lang.Long>
        getInputsCountEstimatedPerReviewerList() {
      return ((bitField0_ & 0x00000001) != 0) ?
               java.util.Collections.unmodifiableList(inputsCountEstimatedPerReviewer_) : inputsCountEstimatedPerReviewer_;
    }
    /**
     * <pre>
     * Estimated number of reviewed inputs per reviewer index.
     * The reviewer indexes are based on task.review.users.
     * An input is considered reviewed by a reviewer if:
     * * the reviewer approved the input
     * * the reviewer rejected the input
     * Note that when a reviewer requests changes for an input, the input is sent to back to work again, so the whole work &amp; review process is restarted.
     * The reviewer will have to review the input again after work has been completed.
     * As such, the review that requests changes for an input is immediately dis-regarded and not counted in this metric.
     * </pre>
     *
     * <code>repeated uint64 inputs_count_estimated_per_reviewer = 3;</code>
     * @return The count of inputsCountEstimatedPerReviewer.
     */
    public int getInputsCountEstimatedPerReviewerCount() {
      return inputsCountEstimatedPerReviewer_.size();
    }
    /**
     * <pre>
     * Estimated number of reviewed inputs per reviewer index.
     * The reviewer indexes are based on task.review.users.
     * An input is considered reviewed by a reviewer if:
     * * the reviewer approved the input
     * * the reviewer rejected the input
     * Note that when a reviewer requests changes for an input, the input is sent to back to work again, so the whole work &amp; review process is restarted.
     * The reviewer will have to review the input again after work has been completed.
     * As such, the review that requests changes for an input is immediately dis-regarded and not counted in this metric.
     * </pre>
     *
     * <code>repeated uint64 inputs_count_estimated_per_reviewer = 3;</code>
     * @param index The index of the element to return.
     * @return The inputsCountEstimatedPerReviewer at the given index.
     */
    public long getInputsCountEstimatedPerReviewer(int index) {
      return inputsCountEstimatedPerReviewer_.getLong(index);
    }
    /**
     * <pre>
     * Estimated number of reviewed inputs per reviewer index.
     * The reviewer indexes are based on task.review.users.
     * An input is considered reviewed by a reviewer if:
     * * the reviewer approved the input
     * * the reviewer rejected the input
     * Note that when a reviewer requests changes for an input, the input is sent to back to work again, so the whole work &amp; review process is restarted.
     * The reviewer will have to review the input again after work has been completed.
     * As such, the review that requests changes for an input is immediately dis-regarded and not counted in this metric.
     * </pre>
     *
     * <code>repeated uint64 inputs_count_estimated_per_reviewer = 3;</code>
     * @param index The index to set the value at.
     * @param value The inputsCountEstimatedPerReviewer to set.
     * @return This builder for chaining.
     */
    public Builder setInputsCountEstimatedPerReviewer(
        int index, long value) {
      ensureInputsCountEstimatedPerReviewerIsMutable();
      inputsCountEstimatedPerReviewer_.setLong(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Estimated number of reviewed inputs per reviewer index.
     * The reviewer indexes are based on task.review.users.
     * An input is considered reviewed by a reviewer if:
     * * the reviewer approved the input
     * * the reviewer rejected the input
     * Note that when a reviewer requests changes for an input, the input is sent to back to work again, so the whole work &amp; review process is restarted.
     * The reviewer will have to review the input again after work has been completed.
     * As such, the review that requests changes for an input is immediately dis-regarded and not counted in this metric.
     * </pre>
     *
     * <code>repeated uint64 inputs_count_estimated_per_reviewer = 3;</code>
     * @param value The inputsCountEstimatedPerReviewer to add.
     * @return This builder for chaining.
     */
    public Builder addInputsCountEstimatedPerReviewer(long value) {
      ensureInputsCountEstimatedPerReviewerIsMutable();
      inputsCountEstimatedPerReviewer_.addLong(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Estimated number of reviewed inputs per reviewer index.
     * The reviewer indexes are based on task.review.users.
     * An input is considered reviewed by a reviewer if:
     * * the reviewer approved the input
     * * the reviewer rejected the input
     * Note that when a reviewer requests changes for an input, the input is sent to back to work again, so the whole work &amp; review process is restarted.
     * The reviewer will have to review the input again after work has been completed.
     * As such, the review that requests changes for an input is immediately dis-regarded and not counted in this metric.
     * </pre>
     *
     * <code>repeated uint64 inputs_count_estimated_per_reviewer = 3;</code>
     * @param values The inputsCountEstimatedPerReviewer to add.
     * @return This builder for chaining.
     */
    public Builder addAllInputsCountEstimatedPerReviewer(
        java.lang.Iterable<? extends java.lang.Long> values) {
      ensureInputsCountEstimatedPerReviewerIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, inputsCountEstimatedPerReviewer_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Estimated number of reviewed inputs per reviewer index.
     * The reviewer indexes are based on task.review.users.
     * An input is considered reviewed by a reviewer if:
     * * the reviewer approved the input
     * * the reviewer rejected the input
     * Note that when a reviewer requests changes for an input, the input is sent to back to work again, so the whole work &amp; review process is restarted.
     * The reviewer will have to review the input again after work has been completed.
     * As such, the review that requests changes for an input is immediately dis-regarded and not counted in this metric.
     * </pre>
     *
     * <code>repeated uint64 inputs_count_estimated_per_reviewer = 3;</code>
     * @return This builder for chaining.
     */
    public Builder clearInputsCountEstimatedPerReviewer() {
      inputsCountEstimatedPerReviewer_ = emptyLongList();
      bitField0_ = (bitField0_ & ~0x00000001);
      onChanged();
      return this;
    }

    private com.google.protobuf.Internal.LongList inputsReviewableCountEstimatedPerReviewer_ = emptyLongList();
    private void ensureInputsReviewableCountEstimatedPerReviewerIsMutable() {
      if (!((bitField0_ & 0x00000002) != 0)) {
        inputsReviewableCountEstimatedPerReviewer_ = mutableCopy(inputsReviewableCountEstimatedPerReviewer_);
        bitField0_ |= 0x00000002;
       }
    }
    /**
     * <pre>
     * The number of inputs actually available for review for each reviewer.
     * Most times, this equals task.metrics.input_source.inputs_count_estimated.
     * Several situations may result in different values:
     * * When task has no review, then this is 0 for each reviewer.
     * * When task has auto-annotation, then this number equals the inputs that have been auto-annotated with AWAITING_REVIEW status. All other inputs are considered completed by the auto-annotation process.
     * * When task has consensus review with approval_threshold_labelers &gt; 0, then it's possible that labelers will approve inputs through consensus, which skips review. In this case, the number of inputs available for review is less than task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = 1, then all inputs are assigned only to one reviewer, so each reviewer will get only a part of the inputs to review. It's expected that the sum(inputs_reviewable_count_estimated) = task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = -1, then all inputs are assigned to all reviewers. However, if an input is rejected, then rejection is final and all other reviewers will not review it. In this case, the number of inputs available for review for other reviewers will be less than task.metrics.input_source.inputs_count_estimated.
     * </pre>
     *
     * <code>repeated uint64 inputs_reviewable_count_estimated_per_reviewer = 4;</code>
     * @return A list containing the inputsReviewableCountEstimatedPerReviewer.
     */
    public java.util.List<java.lang.Long>
        getInputsReviewableCountEstimatedPerReviewerList() {
      return ((bitField0_ & 0x00000002) != 0) ?
               java.util.Collections.unmodifiableList(inputsReviewableCountEstimatedPerReviewer_) : inputsReviewableCountEstimatedPerReviewer_;
    }
    /**
     * <pre>
     * The number of inputs actually available for review for each reviewer.
     * Most times, this equals task.metrics.input_source.inputs_count_estimated.
     * Several situations may result in different values:
     * * When task has no review, then this is 0 for each reviewer.
     * * When task has auto-annotation, then this number equals the inputs that have been auto-annotated with AWAITING_REVIEW status. All other inputs are considered completed by the auto-annotation process.
     * * When task has consensus review with approval_threshold_labelers &gt; 0, then it's possible that labelers will approve inputs through consensus, which skips review. In this case, the number of inputs available for review is less than task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = 1, then all inputs are assigned only to one reviewer, so each reviewer will get only a part of the inputs to review. It's expected that the sum(inputs_reviewable_count_estimated) = task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = -1, then all inputs are assigned to all reviewers. However, if an input is rejected, then rejection is final and all other reviewers will not review it. In this case, the number of inputs available for review for other reviewers will be less than task.metrics.input_source.inputs_count_estimated.
     * </pre>
     *
     * <code>repeated uint64 inputs_reviewable_count_estimated_per_reviewer = 4;</code>
     * @return The count of inputsReviewableCountEstimatedPerReviewer.
     */
    public int getInputsReviewableCountEstimatedPerReviewerCount() {
      return inputsReviewableCountEstimatedPerReviewer_.size();
    }
    /**
     * <pre>
     * The number of inputs actually available for review for each reviewer.
     * Most times, this equals task.metrics.input_source.inputs_count_estimated.
     * Several situations may result in different values:
     * * When task has no review, then this is 0 for each reviewer.
     * * When task has auto-annotation, then this number equals the inputs that have been auto-annotated with AWAITING_REVIEW status. All other inputs are considered completed by the auto-annotation process.
     * * When task has consensus review with approval_threshold_labelers &gt; 0, then it's possible that labelers will approve inputs through consensus, which skips review. In this case, the number of inputs available for review is less than task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = 1, then all inputs are assigned only to one reviewer, so each reviewer will get only a part of the inputs to review. It's expected that the sum(inputs_reviewable_count_estimated) = task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = -1, then all inputs are assigned to all reviewers. However, if an input is rejected, then rejection is final and all other reviewers will not review it. In this case, the number of inputs available for review for other reviewers will be less than task.metrics.input_source.inputs_count_estimated.
     * </pre>
     *
     * <code>repeated uint64 inputs_reviewable_count_estimated_per_reviewer = 4;</code>
     * @param index The index of the element to return.
     * @return The inputsReviewableCountEstimatedPerReviewer at the given index.
     */
    public long getInputsReviewableCountEstimatedPerReviewer(int index) {
      return inputsReviewableCountEstimatedPerReviewer_.getLong(index);
    }
    /**
     * <pre>
     * The number of inputs actually available for review for each reviewer.
     * Most times, this equals task.metrics.input_source.inputs_count_estimated.
     * Several situations may result in different values:
     * * When task has no review, then this is 0 for each reviewer.
     * * When task has auto-annotation, then this number equals the inputs that have been auto-annotated with AWAITING_REVIEW status. All other inputs are considered completed by the auto-annotation process.
     * * When task has consensus review with approval_threshold_labelers &gt; 0, then it's possible that labelers will approve inputs through consensus, which skips review. In this case, the number of inputs available for review is less than task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = 1, then all inputs are assigned only to one reviewer, so each reviewer will get only a part of the inputs to review. It's expected that the sum(inputs_reviewable_count_estimated) = task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = -1, then all inputs are assigned to all reviewers. However, if an input is rejected, then rejection is final and all other reviewers will not review it. In this case, the number of inputs available for review for other reviewers will be less than task.metrics.input_source.inputs_count_estimated.
     * </pre>
     *
     * <code>repeated uint64 inputs_reviewable_count_estimated_per_reviewer = 4;</code>
     * @param index The index to set the value at.
     * @param value The inputsReviewableCountEstimatedPerReviewer to set.
     * @return This builder for chaining.
     */
    public Builder setInputsReviewableCountEstimatedPerReviewer(
        int index, long value) {
      ensureInputsReviewableCountEstimatedPerReviewerIsMutable();
      inputsReviewableCountEstimatedPerReviewer_.setLong(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of inputs actually available for review for each reviewer.
     * Most times, this equals task.metrics.input_source.inputs_count_estimated.
     * Several situations may result in different values:
     * * When task has no review, then this is 0 for each reviewer.
     * * When task has auto-annotation, then this number equals the inputs that have been auto-annotated with AWAITING_REVIEW status. All other inputs are considered completed by the auto-annotation process.
     * * When task has consensus review with approval_threshold_labelers &gt; 0, then it's possible that labelers will approve inputs through consensus, which skips review. In this case, the number of inputs available for review is less than task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = 1, then all inputs are assigned only to one reviewer, so each reviewer will get only a part of the inputs to review. It's expected that the sum(inputs_reviewable_count_estimated) = task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = -1, then all inputs are assigned to all reviewers. However, if an input is rejected, then rejection is final and all other reviewers will not review it. In this case, the number of inputs available for review for other reviewers will be less than task.metrics.input_source.inputs_count_estimated.
     * </pre>
     *
     * <code>repeated uint64 inputs_reviewable_count_estimated_per_reviewer = 4;</code>
     * @param value The inputsReviewableCountEstimatedPerReviewer to add.
     * @return This builder for chaining.
     */
    public Builder addInputsReviewableCountEstimatedPerReviewer(long value) {
      ensureInputsReviewableCountEstimatedPerReviewerIsMutable();
      inputsReviewableCountEstimatedPerReviewer_.addLong(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of inputs actually available for review for each reviewer.
     * Most times, this equals task.metrics.input_source.inputs_count_estimated.
     * Several situations may result in different values:
     * * When task has no review, then this is 0 for each reviewer.
     * * When task has auto-annotation, then this number equals the inputs that have been auto-annotated with AWAITING_REVIEW status. All other inputs are considered completed by the auto-annotation process.
     * * When task has consensus review with approval_threshold_labelers &gt; 0, then it's possible that labelers will approve inputs through consensus, which skips review. In this case, the number of inputs available for review is less than task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = 1, then all inputs are assigned only to one reviewer, so each reviewer will get only a part of the inputs to review. It's expected that the sum(inputs_reviewable_count_estimated) = task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = -1, then all inputs are assigned to all reviewers. However, if an input is rejected, then rejection is final and all other reviewers will not review it. In this case, the number of inputs available for review for other reviewers will be less than task.metrics.input_source.inputs_count_estimated.
     * </pre>
     *
     * <code>repeated uint64 inputs_reviewable_count_estimated_per_reviewer = 4;</code>
     * @param values The inputsReviewableCountEstimatedPerReviewer to add.
     * @return This builder for chaining.
     */
    public Builder addAllInputsReviewableCountEstimatedPerReviewer(
        java.lang.Iterable<? extends java.lang.Long> values) {
      ensureInputsReviewableCountEstimatedPerReviewerIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, inputsReviewableCountEstimatedPerReviewer_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of inputs actually available for review for each reviewer.
     * Most times, this equals task.metrics.input_source.inputs_count_estimated.
     * Several situations may result in different values:
     * * When task has no review, then this is 0 for each reviewer.
     * * When task has auto-annotation, then this number equals the inputs that have been auto-annotated with AWAITING_REVIEW status. All other inputs are considered completed by the auto-annotation process.
     * * When task has consensus review with approval_threshold_labelers &gt; 0, then it's possible that labelers will approve inputs through consensus, which skips review. In this case, the number of inputs available for review is less than task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = 1, then all inputs are assigned only to one reviewer, so each reviewer will get only a part of the inputs to review. It's expected that the sum(inputs_reviewable_count_estimated) = task.metrics.input_source.inputs_count_estimated.
     * * When task has consensus review with approval_threshold_reviewers = -1, then all inputs are assigned to all reviewers. However, if an input is rejected, then rejection is final and all other reviewers will not review it. In this case, the number of inputs available for review for other reviewers will be less than task.metrics.input_source.inputs_count_estimated.
     * </pre>
     *
     * <code>repeated uint64 inputs_reviewable_count_estimated_per_reviewer = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearInputsReviewableCountEstimatedPerReviewer() {
      inputsReviewableCountEstimatedPerReviewer_ = emptyLongList();
      bitField0_ = (bitField0_ & ~0x00000002);
      onChanged();
      return this;
    }

    private com.google.protobuf.Internal.IntList inputsPercentEstimatedPerReviewer_ = emptyIntList();
    private void ensureInputsPercentEstimatedPerReviewerIsMutable() {
      if (!((bitField0_ & 0x00000004) != 0)) {
        inputsPercentEstimatedPerReviewer_ = mutableCopy(inputsPercentEstimatedPerReviewer_);
        bitField0_ |= 0x00000004;
       }
    }
    /**
     * <pre>
     * Estimated percent of review work that was finished per reviewer.
     * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
     * Calculated as inputs_count_estimated_per_reviewer/inputs_reviewable_count_estimated_per_reviewer.
     * As the counts are estimated, the percentage is also estimated.
     * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
     * </pre>
     *
     * <code>repeated uint32 inputs_percent_estimated_per_reviewer = 5;</code>
     * @return A list containing the inputsPercentEstimatedPerReviewer.
     */
    public java.util.List<java.lang.Integer>
        getInputsPercentEstimatedPerReviewerList() {
      return ((bitField0_ & 0x00000004) != 0) ?
               java.util.Collections.unmodifiableList(inputsPercentEstimatedPerReviewer_) : inputsPercentEstimatedPerReviewer_;
    }
    /**
     * <pre>
     * Estimated percent of review work that was finished per reviewer.
     * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
     * Calculated as inputs_count_estimated_per_reviewer/inputs_reviewable_count_estimated_per_reviewer.
     * As the counts are estimated, the percentage is also estimated.
     * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
     * </pre>
     *
     * <code>repeated uint32 inputs_percent_estimated_per_reviewer = 5;</code>
     * @return The count of inputsPercentEstimatedPerReviewer.
     */
    public int getInputsPercentEstimatedPerReviewerCount() {
      return inputsPercentEstimatedPerReviewer_.size();
    }
    /**
     * <pre>
     * Estimated percent of review work that was finished per reviewer.
     * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
     * Calculated as inputs_count_estimated_per_reviewer/inputs_reviewable_count_estimated_per_reviewer.
     * As the counts are estimated, the percentage is also estimated.
     * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
     * </pre>
     *
     * <code>repeated uint32 inputs_percent_estimated_per_reviewer = 5;</code>
     * @param index The index of the element to return.
     * @return The inputsPercentEstimatedPerReviewer at the given index.
     */
    public int getInputsPercentEstimatedPerReviewer(int index) {
      return inputsPercentEstimatedPerReviewer_.getInt(index);
    }
    /**
     * <pre>
     * Estimated percent of review work that was finished per reviewer.
     * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
     * Calculated as inputs_count_estimated_per_reviewer/inputs_reviewable_count_estimated_per_reviewer.
     * As the counts are estimated, the percentage is also estimated.
     * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
     * </pre>
     *
     * <code>repeated uint32 inputs_percent_estimated_per_reviewer = 5;</code>
     * @param index The index to set the value at.
     * @param value The inputsPercentEstimatedPerReviewer to set.
     * @return This builder for chaining.
     */
    public Builder setInputsPercentEstimatedPerReviewer(
        int index, int value) {
      ensureInputsPercentEstimatedPerReviewerIsMutable();
      inputsPercentEstimatedPerReviewer_.setInt(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Estimated percent of review work that was finished per reviewer.
     * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
     * Calculated as inputs_count_estimated_per_reviewer/inputs_reviewable_count_estimated_per_reviewer.
     * As the counts are estimated, the percentage is also estimated.
     * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
     * </pre>
     *
     * <code>repeated uint32 inputs_percent_estimated_per_reviewer = 5;</code>
     * @param value The inputsPercentEstimatedPerReviewer to add.
     * @return This builder for chaining.
     */
    public Builder addInputsPercentEstimatedPerReviewer(int value) {
      ensureInputsPercentEstimatedPerReviewerIsMutable();
      inputsPercentEstimatedPerReviewer_.addInt(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Estimated percent of review work that was finished per reviewer.
     * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
     * Calculated as inputs_count_estimated_per_reviewer/inputs_reviewable_count_estimated_per_reviewer.
     * As the counts are estimated, the percentage is also estimated.
     * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
     * </pre>
     *
     * <code>repeated uint32 inputs_percent_estimated_per_reviewer = 5;</code>
     * @param values The inputsPercentEstimatedPerReviewer to add.
     * @return This builder for chaining.
     */
    public Builder addAllInputsPercentEstimatedPerReviewer(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      ensureInputsPercentEstimatedPerReviewerIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, inputsPercentEstimatedPerReviewer_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Estimated percent of review work that was finished per reviewer.
     * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
     * Calculated as inputs_count_estimated_per_reviewer/inputs_reviewable_count_estimated_per_reviewer.
     * As the counts are estimated, the percentage is also estimated.
     * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
     * </pre>
     *
     * <code>repeated uint32 inputs_percent_estimated_per_reviewer = 5;</code>
     * @return This builder for chaining.
     */
    public Builder clearInputsPercentEstimatedPerReviewer() {
      inputsPercentEstimatedPerReviewer_ = emptyIntList();
      bitField0_ = (bitField0_ & ~0x00000004);
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:clarifai.api.TaskReviewMetrics)
  }

  // @@protoc_insertion_point(class_scope:clarifai.api.TaskReviewMetrics)
  private static final com.clarifai.grpc.api.TaskReviewMetrics DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new com.clarifai.grpc.api.TaskReviewMetrics();
  }

  public static com.clarifai.grpc.api.TaskReviewMetrics getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<TaskReviewMetrics>
      PARSER = new com.google.protobuf.AbstractParser<TaskReviewMetrics>() {
    @java.lang.Override
    public TaskReviewMetrics parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new TaskReviewMetrics(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<TaskReviewMetrics> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<TaskReviewMetrics> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.clarifai.grpc.api.TaskReviewMetrics getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

