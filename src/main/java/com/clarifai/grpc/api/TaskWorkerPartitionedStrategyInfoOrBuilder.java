// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/clarifai/api/resources.proto

package com.clarifai.grpc.api;

public interface TaskWorkerPartitionedStrategyInfoOrBuilder extends
    // @@protoc_insertion_point(interface_extends:clarifai.api.TaskWorkerPartitionedStrategyInfo)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Define how the partitioning should work.
   * </pre>
   *
   * <code>.clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy type = 1;</code>
   * @return The enum numeric value on the wire for type.
   */
  int getTypeValue();
  /**
   * <pre>
   * Define how the partitioning should work.
   * </pre>
   *
   * <code>.clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy type = 1;</code>
   * @return The type.
   */
  com.clarifai.grpc.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy getType();

  /**
   * <pre>
   * How many workers will label each input.
   * </pre>
   *
   * <code>int32 workers_per_input = 2;</code>
   * @return The workersPerInput.
   */
  int getWorkersPerInput();

  /**
   * <pre>
   * In case of weighted partitioning, map user ids to weights.
   * Each labeler will be assigned work proportional to its own weight as compared to the sum of total weight.
   * EXAMPLE:
   * If we have 3 workers, and weights = {1: 30, 2: 30, 3: 40},
   * then first worker will have assigned 30% of the work,
   * second worker will have assigned 30% of the work,
   * and third worker will have assigned 40% of the work.
   * You may use weights which add up to 100, but it's not necessary.
   * For example, weights {1: 30, 2: 30, 3: 40} are equivalent with {1: 3, 2: 3, 3: 4}
   * because they represent the same percentages: {1: 30%, 2: 30%, 3: 40%}.
   * NOTE:
   * Note that no worker should be assigned a weight percentage greater than 1/workers_per_input.
   * It is mathematically impossible to partition the work in such a case.
   * Why? Say, we have 3 workers. And workers_per_input = 2, i.e. each input must be labeled by 2 workers.
   * Let's assign weights {1: 51%, 2: 25%, 3: 24%}.
   * Note that first worker has a weight percentage higher than 1/workers_per_input = 1/2 = 50%.
   * If we have 100 inputs, then a total of 100 * workers_per_input = 200 cumulative inputs will be labeled by these 3 workers.
   * Worker 1 should label 102 cumulative inputs, while worker 2 and worker 3 will label 98 cumulative inputs together.
   * No matter how we assign the 98 cumulative inputs, the 2 workers will be able to label up to 98 actual inputs.
   * This means the remaining 2 inputs will be labeled only by worker 1. This contradicts the worker_per_input = 2 requirement.
   * </pre>
   *
   * <code>.google.protobuf.Struct weights = 3;</code>
   * @return Whether the weights field is set.
   */
  boolean hasWeights();
  /**
   * <pre>
   * In case of weighted partitioning, map user ids to weights.
   * Each labeler will be assigned work proportional to its own weight as compared to the sum of total weight.
   * EXAMPLE:
   * If we have 3 workers, and weights = {1: 30, 2: 30, 3: 40},
   * then first worker will have assigned 30% of the work,
   * second worker will have assigned 30% of the work,
   * and third worker will have assigned 40% of the work.
   * You may use weights which add up to 100, but it's not necessary.
   * For example, weights {1: 30, 2: 30, 3: 40} are equivalent with {1: 3, 2: 3, 3: 4}
   * because they represent the same percentages: {1: 30%, 2: 30%, 3: 40%}.
   * NOTE:
   * Note that no worker should be assigned a weight percentage greater than 1/workers_per_input.
   * It is mathematically impossible to partition the work in such a case.
   * Why? Say, we have 3 workers. And workers_per_input = 2, i.e. each input must be labeled by 2 workers.
   * Let's assign weights {1: 51%, 2: 25%, 3: 24%}.
   * Note that first worker has a weight percentage higher than 1/workers_per_input = 1/2 = 50%.
   * If we have 100 inputs, then a total of 100 * workers_per_input = 200 cumulative inputs will be labeled by these 3 workers.
   * Worker 1 should label 102 cumulative inputs, while worker 2 and worker 3 will label 98 cumulative inputs together.
   * No matter how we assign the 98 cumulative inputs, the 2 workers will be able to label up to 98 actual inputs.
   * This means the remaining 2 inputs will be labeled only by worker 1. This contradicts the worker_per_input = 2 requirement.
   * </pre>
   *
   * <code>.google.protobuf.Struct weights = 3;</code>
   * @return The weights.
   */
  com.google.protobuf.Struct getWeights();
  /**
   * <pre>
   * In case of weighted partitioning, map user ids to weights.
   * Each labeler will be assigned work proportional to its own weight as compared to the sum of total weight.
   * EXAMPLE:
   * If we have 3 workers, and weights = {1: 30, 2: 30, 3: 40},
   * then first worker will have assigned 30% of the work,
   * second worker will have assigned 30% of the work,
   * and third worker will have assigned 40% of the work.
   * You may use weights which add up to 100, but it's not necessary.
   * For example, weights {1: 30, 2: 30, 3: 40} are equivalent with {1: 3, 2: 3, 3: 4}
   * because they represent the same percentages: {1: 30%, 2: 30%, 3: 40%}.
   * NOTE:
   * Note that no worker should be assigned a weight percentage greater than 1/workers_per_input.
   * It is mathematically impossible to partition the work in such a case.
   * Why? Say, we have 3 workers. And workers_per_input = 2, i.e. each input must be labeled by 2 workers.
   * Let's assign weights {1: 51%, 2: 25%, 3: 24%}.
   * Note that first worker has a weight percentage higher than 1/workers_per_input = 1/2 = 50%.
   * If we have 100 inputs, then a total of 100 * workers_per_input = 200 cumulative inputs will be labeled by these 3 workers.
   * Worker 1 should label 102 cumulative inputs, while worker 2 and worker 3 will label 98 cumulative inputs together.
   * No matter how we assign the 98 cumulative inputs, the 2 workers will be able to label up to 98 actual inputs.
   * This means the remaining 2 inputs will be labeled only by worker 1. This contradicts the worker_per_input = 2 requirement.
   * </pre>
   *
   * <code>.google.protobuf.Struct weights = 3;</code>
   */
  com.google.protobuf.StructOrBuilder getWeightsOrBuilder();
}
